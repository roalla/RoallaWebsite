// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ---- NextAuth (Auth.js) + app ----
model Organization {
  id        String   @id @default(cuid())
  name      String
  slug      String?  @unique // optional URL-safe identifier
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  users           User[]
  portalResources PortalResource[]
  portalArticles  PortalArticle[]
  trustedContacts TrustedContact[]

  @@index([slug])
}

// Partner-facing list of trusted contacts (e.g. consultants, supporting services)
model TrustedContact {
  id               String   @id @default(cuid())
  organizationId   String   // partners see only their org's contacts
  name             String
  email            String
  company          String?  // company or practice name
  serviceOrRole    String?  // e.g. Legal, Accounting, Insurance
  url              String?  // website or other link
  linkedInUrl      String?  // LinkedIn profile URL
  notes            String?  @db.Text
  createdByUserId  String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  organization     Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId])
  @@index([createdByUserId])
}

model User {
  id               String    @id @default(cuid())
  name             String?
  email            String?   @unique
  emailVerified    DateTime?
  image            String?
  role             String    @default("member") // primary/legacy; prefer UserRole for multi-role
  passwordHash     String?   // for credentials login
  twoFactorSecret  String?
  twoFactorEnabled Boolean   @default(false)
  organizationId   String?   // for partner scoping; partners see only users in same org
  addedByUserId    String?   // who added this user (for partner add cap and audit)
  lastLoginAt      DateTime? // last sign-in for "last active" in partner team view
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  organization     Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)
  addedBy          User?     @relation("UserAddedBy", fields: [addedByUserId], references: [id], onDelete: SetNull)
  addedUsers       User[]    @relation("UserAddedBy")
  accounts         Account[]
  sessions         Session[]
  passwordResetTokens PasswordResetToken[]
  roles             UserRole[]
  gatedGrantsGranted GatedAccessGrant[]
  gatedRequestsReviewed GatedAccessRequest[]

  @@index([organizationId])
  @@index([addedByUserId])
}

// Multiple roles per user: admin, partner, business, member, etc.
model UserRole {
  id        String   @id @default(cuid())
  userId    String
  role      String   // admin | partner | business | member
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, role])
  @@index([userId])
  @@index([role])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([token])
  @@index([expiresAt])
}

model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?  @db.Text
  access_token      String?  @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?  @db.Text
  session_state     String?
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@id([identifier, token])
}

// Pending 2FA step: token shown after password login when 2FA is enabled
// Success token: used once to complete sign-in after TOTP verify
model AuthPendingToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  type      String   // "2fa_pending" | "2fa_success"
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([token])
  @@index([expiresAt])
}

// ---- Resources portal ----
model AccessRequest {
  id        String   @id @default(cuid())
  email     String
  name      String
  company   String?
  reason    String?
  token     String   @unique
  status    String   @default("pending") // pending, approved, rejected
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([email])
  @@index([status])
  @@index([token])
}

// Admin-curated portal content
model PortalResource {
  id               String   @id @default(cuid())
  title            String
  description      String   @db.Text
  type             String   // Guide, Template, Tool, Framework, etc.
  downloadUrl      String?  // file path or URL for download
  linkUrl          String?  // external link (e.g. to app)
  color            String   @default("from-blue-500 to-blue-600") // Tailwind gradient
  sortOrder        Int      @default(0)
  gated            Boolean  @default(false) // requires NDA + approval to access
  createdByUserId  String?  // partner can only edit own; null = any editor
  organizationId   String?  // null = visible to all; set = visible to this org + shareable link
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  organization     Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([createdByUserId])
  @@index([organizationId])
}

model PortalArticle {
  id               String   @id @default(cuid())
  title            String
  description      String   @db.Text
  readTime         String?
  category         String?
  url              String?  // optional link to full article
  sortOrder        Int      @default(0)
  gated            Boolean  @default(false) // requires NDA + approval to access
  createdByUserId  String?  // partner can only edit own; null = any editor
  organizationId   String?  // null = visible to all; set = visible to this org + shareable link
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  organization     Organization? @relation(fields: [organizationId], references: [id], onDelete: SetNull)

  @@index([createdByUserId])
  @@index([organizationId])
}

// ---- Trust Center: NDA + gated access ----
model NdaAgreement {
  id          String   @id @default(cuid())
  title       String
  body        String   @db.Text // HTML or markdown
  version     String
  effectiveAt DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  signatures  NdaSignature[]
}

model NdaSignature {
  id          String   @id @default(cuid())
  agreementId String
  email       String
  name        String
  company     String?
  signedAt    DateTime @default(now())
  ipAddress   String?
  userAgent   String?  @db.Text
  agreement   NdaAgreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)
  requests    GatedAccessRequest[]

  @@index([email])
  @@index([agreementId])
}

model GatedAccessRequest {
  id              String    @id @default(cuid())
  email           String
  name            String
  company         String?
  ndaSignatureId  String
  status          String    @default("pending") // pending, approved, rejected
  createdAt       DateTime  @default(now())
  reviewedAt      DateTime?
  reviewedByUserId String?
  ndaSignature    NdaSignature @relation(fields: [ndaSignatureId], references: [id], onDelete: Cascade)
  reviewedBy      User?        @relation(fields: [reviewedByUserId], references: [id], onDelete: SetNull)
  items           GatedAccessRequestItem[]
}

model GatedAccessRequestItem {
  id        String   @id @default(cuid())
  requestId String
  resourceId String? // PortalResource id
  articleId  String?  // PortalArticle id
  request   GatedAccessRequest @relation(fields: [requestId], references: [id], onDelete: Cascade)

  @@index([requestId])
}

model GatedAccessGrant {
  id              String   @id @default(cuid())
  email           String
  resourceId      String?  // PortalResource id
  articleId       String?  // PortalArticle id
  grantedAt       DateTime @default(now())
  grantedByUserId String?
  expiresAt       DateTime?
  user            User?    @relation(fields: [grantedByUserId], references: [id], onDelete: SetNull)

  @@index([email])
  @@index([resourceId])
  @@index([articleId])
}

// Magic link token for approved Trust Center access (no login required)
model TrustCenterToken {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([token])
  @@index([email])
}

// Audit log for Trust Center admin actions
model TrustCenterAuditLog {
  id         String   @id @default(cuid())
  action     String   // approved | rejected | resend_link
  requestId  String?
  userId     String?
  metadata   Json?    // e.g. { reason, emailSent }
  createdAt  DateTime @default(now())

  @@index([requestId])
  @@index([userId])
  @@index([createdAt])
}

// Audit log for team/admin actions (user added, roles updated, user deleted)
model TeamAuditLog {
  id           String   @id @default(cuid())
  action       String   // user_added | roles_updated | user_deleted
  actorUserId  String?
  targetUserId String?
  metadata     Json?    // e.g. { email, rolesBefore, rolesAfter }
  createdAt    DateTime @default(now())

  @@index([actorUserId])
  @@index([targetUserId])
  @@index([createdAt])
}
